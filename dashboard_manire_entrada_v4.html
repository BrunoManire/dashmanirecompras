<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Manirê | Dashboard Entradas In Natura</title>
<style>
  :root{
    --bg:#0b0f14; --card:#111826; --text:#e7eef7; --muted:#9db0c5; --line:#223044;
    --good:#26a269; --bad:#e01b24; --warn:#f5c211; --chip:#0f1520;
  }
  body{ margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); }
  header{ padding:18px 20px; border-bottom:1px solid var(--line); display:flex; gap:14px; align-items:flex-end; flex-wrap:wrap; }
  header h1{ font-size:18px; margin:0; }
  .muted{ color:var(--muted); }
  .small{ font-size:11px; }
  .controls{ display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; }
  input[type="text"]{ width:min(900px,92vw); padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:var(--chip); color:var(--text); }
  .datebox{ display:flex; flex-direction:column; gap:4px; }
  .datebox input[type="date"]{ padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:var(--chip); color:var(--text); }
  button{ padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#182234; color:var(--text); cursor:pointer; }
  button:hover{ filter:brightness(1.08); }
  main{ padding:18px 20px 28px; }
  .grid{ display:grid; grid-template-columns:repeat(12,1fr); gap:12px; }
  .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; }
  .span-3{ grid-column:span 3; } .span-4{ grid-column:span 4; } .span-5{ grid-column:span 5; }
  .span-6{ grid-column:span 6; } .span-7{ grid-column:span 7; } .span-8{ grid-column:span 8; }
  .span-12{ grid-column:span 12; }
  @media (max-width:1100px){
    .span-3,.span-4,.span-5,.span-6,.span-7,.span-8{ grid-column:span 12; }
    input[type="text"]{ width:min(100%,92vw); }
  }
  .kpi{ display:flex; justify-content:space-between; gap:10px; align-items:baseline; }
  .kpi .val{ font-size:22px; font-weight:700; }
  .kpi .lbl{ color:var(--muted); font-size:12px; }
  .tag{ font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid var(--line); color:var(--muted); white-space:nowrap; }

  /* TABELAS + SCROLL */
  .tablewrap{
    width:100%;
    overflow:auto;              /* scroll horizontal e vertical */
    max-height:520px;           /* evita tabelas gigantes “empurrando” o layout */
    border:1px solid var(--line);
    border-radius:12px;
    background:#0f1520;
  }
  table{ width:100%; border-collapse:collapse; font-size:12px; min-width:980px; }
  th,td{ padding:8px 8px; border-bottom:1px solid var(--line); vertical-align:top; white-space:nowrap; }
  th{ text-align:left; color:var(--muted); font-weight:600; position:sticky; top:0; background:#0f1520; z-index:2; }
  .pos{ color:var(--good); } .neg{ color:var(--bad); }
  th.sortable{ cursor:pointer; user-select:none; }
  th.sortable:hover{ filter:brightness(1.15); }
  th .sort-ind{ margin-left:6px; opacity:.75; font-size:11px; }
  .note{
    margin:10px 0 0 0; padding:10px 12px; border-radius:12px;
    border:1px dashed var(--line); background:rgba(245,194,17,.08); color:#ffd36b;
  }
</style>
</head>

<body>
<header>
  <div style="flex:1 1 auto;">
    <h1>Dashboard — Entradas In Natura (Manirê)</h1>
    <div class="muted small" id="meta">Carregue o CSV publicado do Google Sheets (output=csv). Depois filtre por período e clique nos cabeçalhos para ordenar.</div>
  </div>

  <div class="controls">
    <input id="csvUrl" type="text"
      value="https://docs.google.com/spreadsheets/d/e/2PACX-1vTr68Lpc3SFv05Wn28gQ3iBCk0jmRdRrWVGM49AE-3bVYR4poLY30Jxfaht2JDgUE5zyNx8vl55nAG2/pub?gid=625178800&single=true&output=csv" />

    <label class="datebox small muted">
      Data inicial
      <input id="dateStart" type="date" />
    </label>

    <label class="datebox small muted">
      Data final
      <input id="dateEnd" type="date" />
    </label>

    <button type="button" onclick="applyDateFilter()">Aplicar período</button>
    <button type="button" onclick="loadData()">Atualizar</button>
  </div>
</header>

<main>
  <div class="grid">
    <div class="card span-3">
      <div class="kpi">
        <div>
          <div class="lbl">Linhas (período)</div>
          <div class="val" id="kpi_rows">—</div>
        </div>
        <span class="tag" id="kpi_lastdate">—</span>
      </div>
    </div>

    <div class="card span-3">
      <div class="kpi">
        <div>
          <div class="lbl">Produtos distintos</div>
          <div class="val" id="kpi_prod">—</div>
        </div>
        <span class="tag" id="kpi_range">—</span>
      </div>
    </div>

    <div class="card span-3">
      <div class="kpi">
        <div>
          <div class="lbl">R$ total (janela 60d)</div>
          <div class="val" id="kpi_rtotal">—</div>
        </div>
        <span class="tag" id="kpi_prevdate">—</span>
      </div>
    </div>

    <div class="card span-3">
      <div class="kpi">
        <div>
          <div class="lbl">Kilos recebidos (janela 60d)</div>
          <div class="val" id="kpi_kilo">—</div>
        </div>
        <span class="tag" id="kpi_missing">—</span>
      </div>
    </div>

    <div class="card span-6">
      <h3 style="margin:0 0 8px 0;">Maiores desvios de preço — DIF. R$ (AK) fora de ±30%</h3>
      <div class="muted small" style="margin-bottom:10px;">
        Regra: lista linhas onde <b>DIF. R$</b> ≥ +30% ou ≤ −30%, usando colunas do Sheets:
        PRODUTO (D), LOTE (A), DATA (C), R$.KG (U), BASE R$ (AJ), DIF. R$ (AK).
        Clique nos cabeçalhos para ordenar.
      </div>
      <div id="warn_price" style="display:none" class="note"></div>
      <div class="tablewrap" id="tbl_price"></div>
    </div>

    <div class="card span-6">
      <h3 style="margin:0 0 8px 0;">Maior desvio — KGS (BRL) vs KILO recebido</h3>
      <div class="muted small" style="margin-bottom:10px;">
        Regra: desvio% = (KILO − KGS(BRL)) ÷ KGS(BRL) (considera KGS(BRL) &gt; 0 e KILO preenchido; janela 60 dias).
        Clique nos cabeçalhos para ordenar.
      </div>
      <div class="tablewrap" id="tbl_kgdev"></div>
    </div>

    <div class="card span-7">
      <h3 style="margin:0 0 8px 0;">Dia anterior disponível — itens fora de ±30% (DIF. R$)</h3>
      <div class="muted small" style="margin-bottom:10px;">
        O dashboard usa a última data do período selecionado e busca a data imediatamente anterior com registros (dentro do período).
        Clique nos cabeçalhos para ordenar.
      </div>
      <div class="tablewrap" id="tbl_prevday"></div>
    </div>

    <div class="card span-5">
      <h3 style="margin:0 0 8px 0;">Curva ABC por KILO</h3>
      <div class="muted small" style="margin-bottom:10px;">
        Base: soma de KILO (janela 60 dias). A: até 80% acumulado, B: até 95%, C: restante.
        Clique nos cabeçalhos para ordenar.
      </div>
      <div class="tablewrap" id="tbl_abc"></div>
    </div>

    <div class="card span-12">
      <h3 style="margin:0 0 8px 0;">Pendências de NF REC. (QLD. ≠ Atual/NRC/Rec.)</h3>
      <div class="muted small" style="margin-bottom:10px;">
        Critério: NF REC. vazio e QLD. diferente de Atual, NRC, Rec. (linhas com QLD vazio não entram).
        Clique nos cabeçalhos para ordenar.
      </div>
      <div class="tablewrap" id="tbl_nf"></div>
    </div>
  </div>
</main>

<script>
/* =========================
   Estado
========================= */
let ALL_DATA = [];
let MIN_DATE = null;
let MAX_DATE = null;

/* =========================
   CSV parser
========================= */
function parseCSV(text){
  const rows = [];
  let row = [];
  let cell = "";
  let inQuotes = false;

  for (let i=0;i<text.length;i++){
    const c = text[i];
    if (c === '"'){
      if (inQuotes && text[i+1] === '"'){ cell += '"'; i++; }
      else inQuotes = !inQuotes;
    } else if (c === ',' && !inQuotes){
      row.push(cell); cell="";
    } else if ((c === '\n' || c === '\r') && !inQuotes){
      if (c === '\r' && text[i+1] === '\n') i++;
      row.push(cell); cell="";
      if (row.some(x => (x||"").trim() !== "")) rows.push(row);
      row = [];
    } else {
      cell += c;
    }
  }
  row.push(cell);
  if (row.some(x => (x||"").trim() !== "")) rows.push(row);
  return rows;
}

/* =========================
   Format
========================= */
function fmtBRL(x){
  if (x == null || !isFinite(x)) return "—";
  return x.toLocaleString("pt-BR",{ style:"currency", currency:"BRL" });
}
function fmtNum(x, d=2){
  if (x == null || !isFinite(x)) return "—";
  return x.toLocaleString("pt-BR",{ maximumFractionDigits:d });
}
function fmtPctHTML(x, d=1){
  if (x == null || !isFinite(x)) return "—";
  const v = x*100;
  const s = v.toFixed(d) + "%";
  return `<span class="${x>=0?'pos':'neg'}">${s}</span>`;
}

/* =========================
   Parsing helpers
========================= */
function toNum(v){
  if (v == null) return null;
  let s = String(v);
  if (!s) return null;

  // normaliza NBSP e espaços
  s = s.replace(/\u00A0/g,' ').trim();
  if (!s) return null;

  const clean = s
    .replace(/\s/g,'')
    .replace(/R\$/gi,'')
    .replace(/\./g,'')
    .replace(',', '.')
    .replace(/[^\d.-]/g,'');
  const n = Number(clean);
  return isFinite(n) ? n : null;
}
function toPct(v){
  if (v == null) return null;
  let s = String(v);
  if (!s) return null;

  s = s.replace(/\u00A0/g,' ').trim();
  if (!s) return null;

  const hasPct = s.includes("%");
  let n = toNum(s);
  if (n == null) return null;

  // se veio com % ou se parece "12,52" (maior que 1), vira fração
  if (hasPct || Math.abs(n) > 1) n = n / 100;
  return n;
}
function toDate(v){
  if (!v) return null;
  let s = String(v).replace(/\u00A0/g,' ').trim();
  if (!s) return null;

  const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (m) return new Date(Number(m[3]), Number(m[2])-1, Number(m[1]));

  const d = new Date(s);
  return isNaN(d) ? null : new Date(d.getFullYear(), d.getMonth(), d.getDate());
}
function toISO(date){ return date.toISOString().slice(0,10); }

/* =========================
   Header mapping
========================= */
function makeIndexMap(headers){
  const idx = new Map();
  headers.forEach((h,i)=>{
    const key = String(h||"")
      .replace(/\u00A0/g,' ')       // NBSP
      .replace(/\s+/g,' ')         // múltiplos espaços
      .trim()
      .toUpperCase();
    idx.set(key, i);
  });
  return idx;
}
function colAny(idxMap, candidates){
  for (const c of candidates){
    const key = String(c).replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim().toUpperCase();
    const i = idxMap.get(key);
    if (i != null) return i;
  }
  return null;
}

/* =========================
   Sortable tables
========================= */
const SORT_STATE = {}; // { "tbl_price": { key:"impacto", dir:"desc" } }

function compareValues(a, b, type, dir){
  const aNull = (a == null || (typeof a === "number" && !isFinite(a)) || a === "");
  const bNull = (b == null || (typeof b === "number" && !isFinite(b)) || b === "");
  if (aNull && bNull) return 0;
  if (aNull) return 1;
  if (bNull) return -1;

  let r = 0;
  if (type === "num"){
    r = Number(a) - Number(b);
  } else if (type === "date"){
    const ta = (a instanceof Date) ? a.getTime() : new Date(a).getTime();
    const tb = (b instanceof Date) ? b.getTime() : new Date(b).getTime();
    r = ta - tb;
  } else {
    r = String(a).localeCompare(String(b), "pt-BR", { sensitivity:"base" });
  }
  return dir === "asc" ? r : -r;
}

function renderSortableTable(containerId, columns, rows, defaultSortKey=null, defaultDir="desc"){
  if (!SORT_STATE[containerId]){
    SORT_STATE[containerId] = { key: defaultSortKey || (columns[0]?.key), dir: defaultDir };
  }
  const st = SORT_STATE[containerId];
  const sortCol = columns.find(c => c.key === st.key) || columns[0];

  const sorted = [...rows].sort((ra, rb) =>
    compareValues(ra[sortCol.key], rb[sortCol.key], sortCol.type, st.dir)
  );

  let html = "<table><thead><tr>";
  for (const c of columns){
    const active = (c.key === st.key);
    const ind = active ? (st.dir === "asc" ? "▲" : "▼") : "";
    html += `<th class="sortable" data-key="${c.key}">${c.label}<span class="sort-ind">${ind}</span></th>`;
  }
  html += "</tr></thead><tbody>";

  for (const r of sorted){
    html += "<tr>";
    for (const c of columns){
      html += `<td>${c.fmt(r)}</td>`;
    }
    html += "</tr>";
  }
  html += "</tbody></table>";

  const el = document.getElementById(containerId);
  el.innerHTML = html;

  el.querySelectorAll("th.sortable").forEach(th=>{
    th.addEventListener("click", ()=>{
      const k = th.getAttribute("data-key");
      if (SORT_STATE[containerId].key === k){
        SORT_STATE[containerId].dir = (SORT_STATE[containerId].dir === "asc") ? "desc" : "asc";
      } else {
        SORT_STATE[containerId].key = k;
        SORT_STATE[containerId].dir = "desc";
      }
      renderSortableTable(containerId, columns, rows, SORT_STATE[containerId].key, SORT_STATE[containerId].dir);
    });
  });
}

/* =========================
   Date inputs
========================= */
function setDateInputsFromData(data){
  const ds = data.map(x=>x.data).filter(Boolean).sort((a,b)=>a-b);
  if (!ds.length) return;

  MIN_DATE = ds[0];
  MAX_DATE = ds[ds.length-1];

  const startEl = document.getElementById("dateStart");
  const endEl   = document.getElementById("dateEnd");

  startEl.min = toISO(MIN_DATE);
  startEl.max = toISO(MAX_DATE);
  endEl.min   = toISO(MIN_DATE);
  endEl.max   = toISO(MAX_DATE);

  if (!startEl.value) startEl.value = toISO(MIN_DATE);
  if (!endEl.value)   endEl.value   = toISO(MAX_DATE);

  document.getElementById("kpi_range").textContent =
    `${new Date(startEl.value).toLocaleDateString("pt-BR")} → ${new Date(endEl.value).toLocaleDateString("pt-BR")}`;
}
function getSelectedDateRange(){
  const sV = document.getElementById("dateStart").value;
  const eV = document.getElementById("dateEnd").value;
  const s = sV ? new Date(sV + "T00:00:00") : null;
  const e = eV ? new Date(eV + "T23:59:59") : null;
  return { s, e };
}
function filterBySelectedDates(data){
  const { s, e } = getSelectedDateRange();
  if (!s || !e) return data;
  return data.filter(x => x.data && x.data >= s && x.data <= e);
}
function applyDateFilter(){
  if (!ALL_DATA.length){
    alert("Carregue o CSV primeiro (Atualizar).");
    return;
  }
  document.getElementById("kpi_range").textContent =
    `${new Date(document.getElementById("dateStart").value).toLocaleDateString("pt-BR")} → ${new Date(document.getElementById("dateEnd").value).toLocaleDateString("pt-BR")}`;
  renderDashboard(filterBySelectedDates(ALL_DATA));
}

/* =========================
   Load data
========================= */
function setWarnPrice(msg){
  const el = document.getElementById("warn_price");
  if (!msg){
    el.style.display = "none";
    el.textContent = "";
    return;
  }
  el.style.display = "block";
  el.textContent = msg;
}

async function loadData(){
  const url = document.getElementById("csvUrl").value.trim();
  if (!url){
    alert("Cole a URL CSV publicada (output=csv).");
    return;
  }

  document.getElementById("meta").textContent = "Carregando CSV...";
  setWarnPrice(null);

  ["tbl_price","tbl_kgdev","tbl_prevday","tbl_abc","tbl_nf"].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.innerHTML = "";
  });

  ["kpi_rows","kpi_prod","kpi_rtotal","kpi_kilo","kpi_lastdate","kpi_prevdate","kpi_missing"].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.textContent = "—";
  });

  let raw;
  try{
    const r = await fetch(url, { cache:"no-store" });
    if (!r.ok) throw new Error("HTTP " + r.status);
    raw = parseCSV(await r.text());
  } catch(err){
    console.error(err);
    document.getElementById("meta").textContent =
      "Falha ao carregar CSV. Confirme que o link termina com output=csv e que o arquivo está publicado.";
    alert("Falha ao carregar CSV.\n\nConfirme que sua URL é do tipo:\n.../pub?gid=XXXX&single=true&output=csv");
    return;
  }

  if (!raw || !raw.length){
    document.getElementById("meta").textContent = "CSV vazio.";
    return;
  }

  const headerRaw = raw[0].map(h => String(h||""));
  const header = headerRaw.map(h => h.replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim());
  const idx = makeIndexMap(header);

  // NOMES CONFORME SEU PRINT (aceitando variações)
  const cLote = colAny(idx, ["LOTE"]);
  const cData = colAny(idx, ["DATA"]);
  const cProd = colAny(idx, ["PRODUTO"]);
  const cForn = colAny(idx, ["FORNECEDOR"]);
  const cNec  = colAny(idx, ["KGS (BRL)", "NEC KGS (BRUNO)"]);
  const cKilo = colAny(idx, ["KILO"]);
  const cRkg  = colAny(idx, ["R$.KG", "R$ KG", "R$/KG"]);
  const cRtot = colAny(idx, ["R$.TOTAL", "R$ TOTAL", "R$TOTAL"]);
  const cNF   = colAny(idx, ["NF REC.", "NF REC"]);
  const cQLD  = colAny(idx, ["QLD.", "QLD"]);
  const cBaseR_byName = colAny(idx, ["BASE R$", "BASE R$", "BASE RS", "BASE R"]);
  const cDifR_byName  = colAny(idx, ["DIF. R$", "DIF R$", "DIF RS", "DIF. RS"]);

  // Fallback por posição (A=0 ... AJ=35, AK=36), SOMENTE se o CSV tiver colunas suficientes.
  const POS_AJ = 35;
  const POS_AK = 36;

  const cBaseR = (cBaseR_byName != null) ? cBaseR_byName : ((header.length > POS_AJ) ? POS_AJ : null);
  const cDifR  = (cDifR_byName  != null) ? cDifR_byName  : ((header.length > POS_AK) ? POS_AK : null);

  const rows = raw.slice(1).filter(r => r.some(x => (String(x||"").replace(/\u00A0/g,' ').trim() !== "")));

  const data = rows.map(r=>{
    const d = (cData!=null) ? toDate(r[cData]) : null;
    const produto = (cProd!=null) ? String(r[cProd]||"").replace(/\u00A0/g,' ').trim() : "";
    return {
      data: d,
      lote: (cLote!=null) ? String(r[cLote]||"").replace(/\u00A0/g,' ').trim() : "",
      produto,
      fornecedor: (cForn!=null) ? String(r[cForn]||"").replace(/\u00A0/g,' ').trim() : "",
      nec:  (cNec!=null)  ? toNum(r[cNec])  : null,
      kilo: (cKilo!=null) ? toNum(r[cKilo]) : null,
      rkg:  (cRkg!=null)  ? toNum(r[cRkg])  : null,
      rtot: (cRtot!=null) ? toNum(r[cRtot]) : null,
      base_r:    (cBaseR!=null) ? toNum(r[cBaseR]) : null, // AJ (ou pelo nome)
      dif_r_pct: (cDifR!=null)  ? toPct(r[cDifR])  : null, // AK (ou pelo nome)
      nf:  (cNF!=null)  ? String(r[cNF]||"").replace(/\u00A0/g,' ').trim() : "",
      qld: (cQLD!=null) ? String(r[cQLD]||"").replace(/\u00A0/g,' ').trim() : ""
    };
  }).filter(x => x.produto && x.data);

  ALL_DATA = data;

  // avisos se AJ/AK não existirem no export
  if (cBaseR == null || cDifR == null){
    setWarnPrice("ATENÇÃO: não encontrei BASE R$ (AJ) e/ou DIF. R$ (AK) no CSV exportado. Confira se essas colunas estão dentro do intervalo publicado e se o CSV tem colunas suficientes (ideal: até AK).");
  }

  // aviso se BASE R$ estiver nula na maioria (indício de coluna errada/fora do export)
  const withBase = data.filter(x => x.base_r != null).length;
  if (data.length && withBase/data.length < 0.2){
    setWarnPrice("ATENÇÃO: BASE R$ está ausente na maior parte das linhas. Isso geralmente significa que a coluna AJ não está no CSV publicado (o intervalo publicado não inclui AJ/AK) ou o cabeçalho veio diferente. Confirme que o export inclui até AK.");
  }

  setDateInputsFromData(ALL_DATA);
  renderDashboard(filterBySelectedDates(ALL_DATA));
}

/* =========================
   Render dashboard
========================= */
function renderDashboard(dataFiltered){
  const datesSel = dataFiltered.map(x=>x.data).filter(Boolean).sort((a,b)=>a-b);
  const selMin = datesSel.length ? datesSel[0] : null;
  const selMax = datesSel.length ? datesSel[datesSel.length-1] : null;

  // janela 60d baseada na última data do período selecionado
  const maxDate = selMax || new Date();
  const winStart = new Date(maxDate.getTime() - 60*24*3600*1000);
  const inWin = dataFiltered.filter(x => x.data && x.data >= winStart && x.data <= maxDate);

  // KPIs
  const linhas = dataFiltered.length;
  const produtos = new Set(dataFiltered.map(x=>x.produto)).size;
  const rTotal60 = inWin.map(x=>x.rtot).filter(x=>x!=null).reduce((s,v)=>s+v,0);
  const kilos60  = inWin.map(x=>x.kilo).filter(x=>x!=null).reduce((s,v)=>s+v,0);
  const kiloMissing = inWin.length ? (inWin.filter(x=>x.kilo==null).length / inWin.length) : 0;

  document.getElementById("kpi_rows").textContent = fmtNum(linhas,0);
  document.getElementById("kpi_prod").textContent = fmtNum(produtos,0);
  document.getElementById("kpi_rtotal").textContent = rTotal60 ? fmtBRL(rTotal60) : "—";
  document.getElementById("kpi_kilo").textContent  = kilos60  ? fmtNum(kilos60,0) : "—";
  document.getElementById("kpi_lastdate").textContent = selMax ? `até ${selMax.toLocaleDateString("pt-BR")}` : "—";
  document.getElementById("kpi_missing").textContent = inWin.length ? `KILO ausente: ${(kiloMissing*100).toFixed(1)}%` : "—";

  // Dia anterior
  const uniqueDates = Array.from(new Set(inWin.map(x=>toISO(x.data)))).sort();
  const ydayISO = uniqueDates.length>1 ? uniqueDates[uniqueDates.length-2] : null;
  document.getElementById("kpi_prevdate").textContent = ydayISO ? `dia ant.: ${new Date(ydayISO).toLocaleDateString("pt-BR")}` : "dia ant.: —";

  const rangeTxt = (selMin && selMax)
    ? `Período: ${selMin.toLocaleDateString("pt-BR")} → ${selMax.toLocaleDateString("pt-BR")}`
    : "Período: —";

  document.getElementById("meta").textContent =
    `OK — ${fmtNum(linhas,0)} linhas (período selecionado). ${rangeTxt}. ` +
    `Janela 60d: ${winStart.toLocaleDateString("pt-BR")} → ${maxDate.toLocaleDateString("pt-BR")}. ` +
    `Ordene clicando nos cabeçalhos.`;

  /* =========================
     1) RELATÓRIO AJ/AK — DIF. R$ fora de ±30%
  ========================= */
  const priceAlerts = inWin
    .filter(x => x.dif_r_pct != null && isFinite(x.dif_r_pct))
    .filter(x => Math.abs(x.dif_r_pct) >= 0.30)
    .map(x=>{
      const impacto = (x.kilo!=null && x.rkg!=null && x.base_r!=null)
        ? (x.rkg - x.base_r) * x.kilo
        : null;
      return { ...x, impacto };
    });

  if (priceAlerts.length){
    const columns = [
      { label:"Produto", key:"produto", type:"text", fmt:r=>r.produto },
      { label:"Lote", key:"lote", type:"text", fmt:r=>r.lote||"" },
      { label:"Data", key:"data", type:"date", fmt:r=>r.data ? r.data.toLocaleDateString("pt-BR") : "" },
      { label:"R$.KG", key:"rkg", type:"num", fmt:r=>fmtBRL(r.rkg) },
      { label:"Base R$", key:"base_r", type:"num", fmt:r=>fmtBRL(r.base_r) },
      { label:"DIF. R$", key:"dif_r_pct", type:"num", fmt:r=>fmtPctHTML(r.dif_r_pct,1) },
      { label:"KILO", key:"kilo", type:"num", fmt:r=>fmtNum(r.kilo,2) },
      { label:"Impacto (R$)", key:"impacto", type:"num", fmt:r=> (r.impacto==null ? "—" : fmtBRL(r.impacto)) }
    ];
    renderSortableTable("tbl_price", columns, priceAlerts, "impacto", "desc");
  } else {
    document.getElementById("tbl_price").innerHTML =
      "<div class='muted small' style='padding:10px 12px;'>Nenhuma linha na janela (60 dias) com DIF. R$ fora de ±30%.</div>";
  }

  /* =========================
     2) KGS(BRL) vs KILO (desvio)
  ========================= */
  const kgdev = [];
  for (const r of inWin){
    if (r.nec==null || r.nec===0 || r.kilo==null) continue;
    const dev = (r.kilo - r.nec)/r.nec;
    kgdev.push({ ...r, dev });
  }

  if (kgdev.length){
    const columns = [
      { label:"Data", key:"data", type:"date", fmt:r=>r.data ? r.data.toLocaleDateString("pt-BR") : "" },
      { label:"Produto", key:"produto", type:"text", fmt:r=>r.produto },
      { label:"Fornecedor", key:"fornecedor", type:"text", fmt:r=>r.fornecedor },
      { label:"KGS (BRL)", key:"nec", type:"num", fmt:r=>fmtNum(r.nec,2) },
      { label:"KILO", key:"kilo", type:"num", fmt:r=>fmtNum(r.kilo,2) },
      { label:"Desvio", key:"dev", type:"num", fmt:r=>fmtPctHTML(r.dev,1) }
    ];
    renderSortableTable("tbl_kgdev", columns, kgdev, "dev", "desc");
  } else {
    document.getElementById("tbl_kgdev").innerHTML =
      "<div class='muted small' style='padding:10px 12px;'>Sem dados suficientes (KGS(BRL) e KILO) na janela de 60 dias.</div>";
  }

  /* =========================
     3) Dia anterior — DIF. R$ fora de ±30%
  ========================= */
  if (ydayISO){
    const yRows = inWin
      .filter(x => toISO(x.data) === ydayISO)
      .filter(x => x.dif_r_pct != null && isFinite(x.dif_r_pct))
      .filter(x => Math.abs(x.dif_r_pct) >= 0.30);

    if (yRows.length){
      const columns = [
        { label:"Dia", key:"data", type:"date", fmt:r=>new Date(ydayISO).toLocaleDateString("pt-BR") },
        { label:"Produto", key:"produto", type:"text", fmt:r=>r.produto },
        { label:"Fornecedor", key:"fornecedor", type:"text", fmt:r=>r.fornecedor },
        { label:"R$.KG", key:"rkg", type:"num", fmt:r=>fmtBRL(r.rkg) },
        { label:"Base R$", key:"base_r", type:"num", fmt:r=>fmtBRL(r.base_r) },
        { label:"DIF. R$", key:"dif_r_pct", type:"num", fmt:r=>fmtPctHTML(r.dif_r_pct,1) },
        { label:"Lote", key:"lote", type:"text", fmt:r=>r.lote||"" }
      ];
      renderSortableTable("tbl_prevday", columns, yRows, "dif_r_pct", "desc");
    } else {
      document.getElementById("tbl_prevday").innerHTML =
        "<div class='muted small' style='padding:10px 12px;'>Nenhum item com DIF. R$ fora de ±30% no “dia anterior”.</div>";
    }
  } else {
    document.getElementById("tbl_prevday").innerHTML =
      "<div class='muted small' style='padding:10px 12px;'>Sem histórico suficiente para identificar “dia anterior”.</div>";
  }

  /* =========================
     4) ABC por KILO
  ========================= */
  const kiloByProd = new Map();
  for (const r of inWin){
    if (r.kilo==null) continue;
    kiloByProd.set(r.produto, (kiloByProd.get(r.produto)||0) + r.kilo);
  }
  const abc = Array.from(kiloByProd.entries()).map(([produto,kilo])=>({ produto, kilo }));
  abc.sort((a,b)=>b.kilo-a.kilo);

  const totalK = abc.reduce((s,x)=>s+x.kilo,0) || 1;
  let acc = 0;
  const abcRows = abc.map(x=>{
    acc += x.kilo;
    const accPct = acc/totalK;
    const cls = accPct<=0.8 ? "A" : (accPct<=0.95 ? "B" : "C");
    return { ...x, accPct, cls };
  });

  if (abcRows.length){
    const columns = [
      { label:"Produto", key:"produto", type:"text", fmt:r=>r.produto },
      { label:"KILO (60d)", key:"kilo", type:"num", fmt:r=>fmtNum(r.kilo,0) },
      { label:"% acum.", key:"accPct", type:"num", fmt:r=>fmtPctHTML(r.accPct,1) },
      { label:"Classe", key:"cls", type:"text", fmt:r=>r.cls }
    ];
    renderSortableTable("tbl_abc", columns, abcRows, "kilo", "desc");
  } else {
    document.getElementById("tbl_abc").innerHTML =
      "<div class='muted small' style='padding:10px 12px;'>Sem KILO suficiente na janela de 60 dias.</div>";
  }

  /* =========================
     5) Pendências NF REC
  ========================= */
  const bad = new Set(["ATUAL","NRC","REC.","REC"]);
  const pend = inWin.filter(x=>{
    const q = (x.qld||"").replace(/\u00A0/g,' ').trim().toUpperCase();
    return (!x.nf) && q && !bad.has(q);
  });

  if (pend.length){
    const columns = [
      { label:"Data", key:"data", type:"date", fmt:r=>r.data ? r.data.toLocaleDateString("pt-BR") : "" },
      { label:"Produto", key:"produto", type:"text", fmt:r=>r.produto },
      { label:"Fornecedor", key:"fornecedor", type:"text", fmt:r=>r.fornecedor },
      { label:"QLD.", key:"qld", type:"text", fmt:r=>(r.qld||"") },
      { label:"NF REC.", key:"nf", type:"text", fmt:r=>(r.nf||"") }
    ];
    renderSortableTable("tbl_nf", columns, pend, "data", "desc");
  } else {
    document.getElementById("tbl_nf").innerHTML =
      "<div class='muted small' style='padding:10px 12px;'>Sem pendências de NF REC (com QLD válido) na janela de 60 dias.</div>";
  }
}

// Se quiser carregar automaticamente ao abrir, descomente:
// window.addEventListener("load", loadData);
</script>
</body>
</html>
